import '../../entities/booking.dart';
import '../../entities/time_slot.dart';
import '../../entities/payment_info.dart';
import '../../entities/user.dart';
import '../../repositories/booking_repository.dart';
import '../../repositories/auth_repository.dart';
import '../../../core/error/result.dart';
import '../../../core/error/exceptions.dart';

class CreateBookingUseCase {
  final BookingRepository _bookingRepository;
  final AuthRepository _authRepository;

  const CreateBookingUseCase(this._bookingRepository, this._authRepository);

  /// Creates a new booking with payment processing
  /// 
  /// Validates user authentication, time slot availability, and processes payment
  /// Returns [Result<Booking>] with created booking on success or exception on failure
  Future<Result<Booking>> execute({
    required String timeSlotId,
    required BookingType type,
    String? itemId,
    required double totalAmount,
    required PaymentInfo paymentInfo,
    String? notes,
  }) async {
    try {
      // Check user authentication
      final currentUser = await _authRepository.getCurrentUser();
      if (currentUser == null) {
        return Failure(AuthException('로그인이 필요합니다'));
      }

      // Validate input data
      final validationError = _validateBookingData(
        timeSlotId: timeSlotId,
        totalAmount: totalAmount,
        notes: notes,
      );
      if (validationError != null) {
        return Failure(ValidationException(validationError));
      }

      // Get available time slots to check availability
      final timeSlotsResult = await _bookingRepository.getAvailableTimeSlots(
        itemId ?? '',
        DateTime.now(),
        DateTime.now().add(const Duration(days: 365)),
      );

      if (timeSlotsResult.isFailure) {
        return Failure(timeSlotsResult.exception!);
      }

      final timeSlots = timeSlotsResult.data!;
      final selectedTimeSlot = timeSlots.firstWhere(
        (slot) => slot.id == timeSlotId,
        orElse: () => throw NotFoundException('선택한 시간대를 찾을 수 없습니다'),
      );

      // Check time slot availability
      if (!selectedTimeSlot.hasAvailableCapacity) {
        return Failure(BusinessLogicException('선택한 시간대가 만석입니다'));
      }

      if (!selectedTimeSlot.isBookingAllowed) {
        return Failure(BusinessLogicException('예약 마감 시간이 지났습니다'));
      }

      // Process payment first
      final paymentResult = await _bookingRepository.processPayment(paymentInfo);
      if (paymentResult.isFailure) {
        return Failure(paymentResult.exception!);
      }

      final processedPayment = paymentResult.data!;

      // Create booking
      final booking = Booking(
        id: '', // Will be generated by repository
        userId: currentUser.id,
        timeSlotId: timeSlotId,
        type: type,
        itemId: itemId,
        status: processedPayment.isSuccessful 
            ? BookingStatus.confirmed 
            : BookingStatus.pending,
        totalAmount: totalAmount,
        paymentInfo: processedPayment,
        notes: notes?.trim(),
        createdAt: DateTime.now(),
      );

      // Save booking to repository
      final result = await _bookingRepository.createBooking(booking);
      
      return result.fold(
        onSuccess: (createdBooking) => Success(createdBooking),
        onFailure: (exception) => Failure(exception),
      );
    } catch (e) {
      return Failure(UnknownException('예약 생성 중 오류가 발생했습니다: ${e.toString()}'));
    }
  }

  String? _validateBookingData({
    required String timeSlotId,
    required double totalAmount,
    String? notes,
  }) {
    // Validate time slot ID
    if (timeSlotId.isEmpty) {
      return '시간대를 선택해주세요';
    }

    // Validate amount
    final amountError = Booking.validateAmount(totalAmount);
    if (amountError != null) return amountError;

    // Validate notes
    final notesError = Booking.validateNotes(notes);
    if (notesError != null) return notesError;

    return null;
  }
}